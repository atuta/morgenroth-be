import datetime
from django.db.models import Max, Sum
from django.utils.dateparse import parse_date
from datetime import datetime as dt_datetime, date as dt_date, time as dt_time
from decimal import Decimal, InvalidOperation
from django.utils import timezone
from django.forms.models import model_to_dict
from django.core.exceptions import ObjectDoesNotExist
from django.db import IntegrityError

from mapp.models import CustomUser, AttendanceSession, OvertimeAllowance, AdvancePayment, StatutoryDeduction
from mapp.classes.payroll_service import PayrollService
from mapp.classes.logs.logs import Logs


class UserService:
    @classmethod
    def generate_payroll_report(cls, start_date, end_date):
        """
        Return payslip data for ALL users within a date range.
        Output → one record per user summarised + nested breakdowns.
        Also logs per-user payroll details and final summary totals.
        """

        try:
            # --- Safe date parsing ---
            if isinstance(start_date, (dt_datetime, dt_date)):
                start_date_parsed = start_date
            elif isinstance(start_date, str):
                start_date_parsed = parse_date(start_date)
            else:
                return {"status": "error", "message": "invalid_start_date"}

            if isinstance(end_date, (dt_datetime, dt_date)):
                end_date_parsed = end_date
            elif isinstance(end_date, str):
                end_date_parsed = parse_date(end_date)
            else:
                return {"status": "error", "message": "invalid_end_date"}

            if not start_date_parsed or not end_date_parsed:
                return {"status": "error", "message": "invalid_date_range"}

            # Expand to full day for datetime fields
            start_datetime = dt_datetime.combine(start_date_parsed, dt_time.min)
            end_datetime = dt_datetime.combine(end_date_parsed, dt_time.max)

            users = CustomUser.objects.all()
            final_output = []

            # --- Initialize overall totals ---
            overall_totals = {
                "total_hours": 0,
                "total_base_pay": 0,
                "total_overtime": 0,
                "gross_pay": 0,
                "total_deductions": 0,
                "total_advance": 0,
                "net_pay": 0
            }
            overall_deductions = []
            overall_advances = []
            overall_overtime = []

            # Fetch global deductions once
            deductions_result = PayrollService.get_all_deductions()
            deductions_list = deductions_result.get("message") if deductions_result.get("status") == "success" else []

            for user in users:

                # --- Hourly Rate ---
                rate_result = PayrollService.get_hourly_rate(user)
                if rate_result.get("status") != "success":
                    hourly_rate = 0
                    currency = "KES"
                else:
                    hourly_rate = rate_result["message"]["hourly_rate"]
                    currency = rate_result["message"]["currency"]

                # --- Attendance ---
                attendance_qs = AttendanceSession.objects.filter(
                    user=user,
                    date__range=[start_date_parsed, end_date_parsed],
                    status='closed'
                ).order_by("date")

                attendance_breakdown = []
                total_hours = 0
                total_base_pay = 0

                for a in attendance_qs:
                    h = float(a.total_hours or 0)
                    p = h * hourly_rate
                    total_hours += h
                    total_base_pay += p
                    attendance_breakdown.append({
                        "date": a.date.strftime("%Y-%m-%d"),
                        "hours": h,
                        "pay": float(p),
                        "notes": a.notes or ""
                    })

                if not attendance_qs.exists():
                    attendance_breakdown.append({"date": None, "hours": 0, "pay": 0, "notes": ""})

                # --- Overtime ---
                overtime_qs = OvertimeAllowance.objects.filter(
                    user=user,
                    date__range=[start_date_parsed, end_date_parsed]
                ).order_by("date")

                overtime_breakdown = []
                total_overtime = 0

                for o in overtime_qs:
                    amount = float(o.amount or 0)
                    total_overtime += amount
                    overtime_breakdown.append({
                        "date": o.date.strftime("%Y-%m-%d"),
                        "hours": float(o.hours),
                        "amount": amount,
                        "remarks": o.remarks or ""
                    })

                if not overtime_qs.exists():
                    overtime_breakdown.append({"date": None, "hours": 0, "amount": 0, "remarks": ""})

                # --- Gross Pay ---
                gross = total_base_pay + total_overtime

                # --- Deductions ---
                deductions_breakdown = []
                total_deductions = 0

                for d in deductions_list:
                    amount = gross * (d.get("percentage", 0) / 100)
                    total_deductions += amount
                    deductions_breakdown.append({
                        "name": d.get("name"),
                        "percentage": d.get("percentage"),
                        "amount": float(amount)
                    })

                if not deductions_list:
                    deductions_breakdown.append({"name": "None", "percentage": 0, "amount": 0})

                # --- Advance Payments ---
                advances_qs = AdvancePayment.objects.filter(
                    user=user,
                    created_at__range=[start_datetime, end_datetime]
                )

                advance_breakdown = []
                total_advance = 0

                for ad in advances_qs:
                    amt = float(ad.amount or 0)
                    total_advance += amt
                    advance_breakdown.append({
                        "date": ad.created_at.strftime("%Y-%m-%d"),
                        "amount": amt,
                        "remarks": ad.remarks or "",
                        "approved_by": ad.approved_by.full_name if ad.approved_by else None
                    })

                if not advances_qs.exists():
                    advance_breakdown.append({"date": None, "amount": 0, "remarks": "", "approved_by": None})

                # --- Net Pay ---
                net = gross - total_deductions - total_advance

                # --- Update overall totals ---
                overall_totals["total_hours"] += total_hours
                overall_totals["total_base_pay"] += total_base_pay
                overall_totals["total_overtime"] += total_overtime
                overall_totals["gross_pay"] += gross
                overall_totals["total_deductions"] += total_deductions
                overall_totals["total_advance"] += total_advance
                overall_totals["net_pay"] += net

                # --- Update overall line-item lists ---
                overall_deductions.extend(deductions_breakdown)
                overall_advances.extend(advance_breakdown)
                overall_overtime.extend(overtime_breakdown)

                # --- Enhanced Debug log per user ---
                # --- Enhanced Debug log per user with full items ---
                log_msg = (
                    f"Payroll for user {user.full_name} | "
                    f"attendance={attendance_qs.count()} | "
                    f"hourly_rate={hourly_rate} | gross={gross} | "
                    f"deductions_total={total_deductions} | advance_total={total_advance} | net_pay={net} | "
                    f"deductions_items={deductions_breakdown} | "
                    f"advances_items={advance_breakdown} | "
                    f"overtime_items={overtime_breakdown}"
                )
                # Logs.atuta_technical_logger(f"payroll_user_debug: {log_msg}")

                # --- Store per user ---
                final_output.append({
                    "user": {
                        "id": str(user.user_id),
                        "full_name": user.full_name,
                        "email": user.email
                    },
                    "currency": currency,
                    "summary": {
                        "total_hours": float(total_hours),
                        "total_base_pay": float(total_base_pay),
                        "total_overtime": float(total_overtime),
                        "gross_pay": float(gross),
                        "total_deductions": float(total_deductions),
                        "total_advance": float(total_advance),
                        "net_pay": float(net)
                    },
                    "attendance": attendance_breakdown,
                    "overtime": overtime_breakdown,
                    "deductions": deductions_breakdown,
                    "advances": advance_breakdown
                })

            # --- Final summary log after processing all users ---
            summary_msg = (
                f"Payroll Summary | total_users={len(users)} | "
                f"total_hours={overall_totals['total_hours']} | "
                f"total_base_pay={overall_totals['total_base_pay']} | "
                f"total_overtime={overall_totals['total_overtime']} | "
                f"gross_pay={overall_totals['gross_pay']} | "
                f"total_deductions={overall_totals['total_deductions']} | "
                f"total_advance={overall_totals['total_advance']} | "
                f"net_pay={overall_totals['net_pay']} | "
                f"deductions_items={len(overall_deductions)} | "
                f"advances_items={len(overall_advances)} | "
                f"overtime_items={len(overall_overtime)}"
            )
            # Logs.atuta_logger(f"payroll_summary_debug: {summary_msg}")

            payroll = {
                "status": "success",
                "message": {
                    "start_date": start_date_parsed,
                    "end_date": end_date_parsed,
                    "employees": final_output,
                    "totals": overall_totals,
                    "deductions_items": overall_deductions,
                    "advances_items": overall_advances,
                    "overtime_items": overall_overtime
                }
            }
            Logs.atuta_logger(payroll)
            return payroll

        except Exception as e:
            Logs.atuta_technical_logger("payslip_range_error", exc_info=e)
            return {"status": "error", "message": "range_generation_failed"}



    @classmethod
    def admin_dashboard_metrics(cls, month=None, year=None):
        """
        Returns a combined dashboard summary:
        1. Payroll metrics:
        - total_salary: sum of all users' net salary (hours * rate + overtime - statutory deductions - advances)
        2. Attendance statistics:
        - all_users_count
        - present_count
        - absent_count
        - on_leave_count
        - lists of users for each category
        Defaults to current month/year if none provided.
        """
        if month is None or year is None:
            today = timezone.now()
            month = month or today.month
            year = year or today.year

        try:
            # --- Payroll Metrics ---
            total_salary = Decimal("0.00")
            users = CustomUser.objects.all()
            statutory_deductions = StatutoryDeduction.objects.all()

            for user in users:
                # Total hours for the period
                hours_data = PayrollService.get_total_hours_for_period(user, month, year)
                total_hours = Decimal(hours_data['message']['total_hours']) if hours_data.get('status') == 'success' else Decimal("0.00")

                # Gross salary = total_hours * hourly_rate
                gross_salary = total_hours * user.hourly_rate

                # Add overtime
                overtime_total = OvertimeAllowance.objects.filter(
                    user=user, year=year, month=month
                ).aggregate(total_amount=Sum('amount'))['total_amount'] or Decimal("0.00")
                gross_salary += Decimal(overtime_total)

                # Total advance for the period
                advance_data = PayrollService.get_total_advance_for_period(user, month, year)
                total_advance_user = Decimal(advance_data['message']['total_advance']) if advance_data.get('status') == 'success' else Decimal("0.00")

                # Apply statutory deductions
                total_deduction = sum((gross_salary * d.percentage / 100) for d in statutory_deductions)

                # Net salary for this user
                net_salary = gross_salary - total_deduction - total_advance_user

                total_salary += net_salary

            payroll_metrics = {
                "total_salary": round(total_salary, 2),
                "month": month,
                "year": year
            }

            # --- Attendance Statistics ---
            all_users_qs = users
            present_qs = all_users_qs.filter(is_present_today=True)
            on_leave_qs = all_users_qs.filter(is_on_leave=True)
            absent_qs = all_users_qs.filter(is_present_today=False, is_on_leave=False)

            attendance_metrics = {
                "all_users_count": all_users_qs.count(),
                "present_count": present_qs.count(),
                "absent_count": absent_qs.count(),
                "on_leave_count": on_leave_qs.count(),
                "all_users": list(all_users_qs.values("user_id", "first_name", "last_name", "is_present_today", "is_on_leave")),
                "present_users": list(present_qs.values("user_id", "first_name", "last_name")),
                "absent_users": list(absent_qs.values("user_id", "first_name", "last_name")),
                "on_leave_users": list(on_leave_qs.values("user_id", "first_name", "last_name")),
            }

            return {
                "status": "success",
                "payroll_metrics": payroll_metrics,
                "attendance_metrics": attendance_metrics
            }

        except Exception as e:
            Logs.atuta_technical_logger("admin_dashboard_metrics_failed", exc_info=e)
            return {"status": "error", "message": "admin_dashboard_metrics_failed"}


    @classmethod
    def monthly_pay_metrics(cls, month=None, year=None):
        """
        Returns a summary of payroll metrics for the given month/year:
        - total_salary: sum of all users' salary (hours * rate + overtime - statutory deductions)
        - total_advance: sum of all advances
        - total_net_due: total_salary - total_advance
        Defaults to current month/year if not provided.
        """
        if month is None or year is None:
            today = timezone.now()
            month = month or today.month
            year = year or today.year

        try:
            total_salary = Decimal("0.00")
            users = CustomUser.objects.all()
            statutory_deductions = StatutoryDeduction.objects.all()

            for user in users:
                # Sum hours worked in the month
                attendance = AttendanceSession.objects.filter(
                    user=user,
                    date__year=year,
                    date__month=month,
                    total_hours__isnull=False
                ).aggregate(total_hours=Sum('total_hours'))['total_hours'] or Decimal("0.00")

                gross_salary = Decimal(attendance) * user.hourly_rate

                # Add total overtime for the month
                overtime_total = OvertimeAllowance.objects.filter(
                    user=user,
                    year=year,
                    month=month
                ).aggregate(total_amount=Sum('amount'))['total_amount'] or Decimal("0.00")

                gross_salary += Decimal(overtime_total)

                # Apply statutory deductions individually
                total_deduction = Decimal("0.00")
                for deduction in statutory_deductions:
                    total_deduction += (gross_salary * deduction.percentage / 100)

                net_salary = gross_salary - total_deduction

                total_salary += net_salary

            # Total advances for the month
            total_advance = AdvancePayment.objects.filter(
                year=year,
                month=month
            ).aggregate(total=Sum('amount'))['total'] or Decimal("0.00")

            total_net_due = total_salary - total_advance

            return {
                "month": month,
                "year": year,
                "total_salary": round(total_salary, 2),
                "total_advance": round(total_advance, 2),
                "total_net_due": round(total_net_due, 2)
            }

        except Exception as e:
            Logs.atuta_technical_logger("monthly_pay_metrics_failed", exc_info=e)
            return {"status": "error", "message": "monthly_pay_metrics_failed"}

    @classmethod
    def attendance_statistics(cls):
        """
        Returns a summary dictionary of users:
        - all_users: total count of users
        - present_today: list of users present today
        - absent_today: list of users absent today (not on leave)
        - on_leave: list of users currently on leave
        """
        try:
            all_users_qs = CustomUser.objects.all()
            present_qs = all_users_qs.filter(is_present_today=True)
            on_leave_qs = all_users_qs.filter(is_on_leave=True)
            absent_qs = all_users_qs.filter(is_present_today=False, is_on_leave=False)

            return {
                "all_users_count": all_users_qs.count(),
                "present_count": present_qs.count(),
                "absent_count": absent_qs.count(),
                "on_leave_count": on_leave_qs.count(),
                "all_users": list(all_users_qs.values("user_id", "first_name", "last_name", "is_present_today", "is_on_leave")),
                "present_users": list(present_qs.values("user_id", "first_name", "last_name")),
                "absent_users": list(absent_qs.values("user_id", "first_name", "last_name")),
                "on_leave_users": list(on_leave_qs.values("user_id", "first_name", "last_name")),
            }

        except Exception as e:
            Logs.atuta_technical_logger("attendance_statistics_failed", exc_info=e)
            return {"status": "error", "message": "attendance_statistics_failed"}
        
    @classmethod
    def update_user_holiday_status(cls, user_id, is_on_holiday=None):
        """
        Update a user's is_on_holiday status if a valid boolean value is provided.
        Logs both incoming data and updated status.
        """
        try:
            # Log incoming data
            Logs.atuta_logger(f"Received holiday status update for user {user_id}: is_on_holiday={is_on_holiday}")

            user = CustomUser.objects.get(user_id=user_id)

            if is_on_holiday is None:
                Logs.atuta_logger(f"No holiday status provided for user {user_id}")
                return {"status": "info", "message": "no_status_provided"}

            # Ensure boolean type
            if isinstance(is_on_holiday, str):
                val = is_on_holiday.strip().lower()
                if val in ("true", "1", "yes"):
                    is_on_holiday = True
                elif val in ("false", "0", "no"):
                    is_on_holiday = False
                else:
                    Logs.atuta_logger(f"Invalid is_on_holiday value received for user {user_id}: {is_on_holiday}")
                    return {"status": "error", "message": "invalid_status_value"}
            elif not isinstance(is_on_holiday, bool):
                Logs.atuta_logger(f"Invalid is_on_holiday type for user {user_id}: {type(is_on_holiday)}")
                return {"status": "error", "message": "invalid_status_type"}

            user.is_on_holiday = is_on_holiday
            user.save()

            Logs.atuta_logger(f"Successfully updated holiday status for user {user_id} to {is_on_holiday}")
            return {"status": "success", "message": "holiday_status_updated"}

        except ObjectDoesNotExist:
            Logs.atuta_logger(f"User {user_id} not found for holiday status update")
            return {"status": "error", "message": "user_not_found"}
        except Exception as e:
            Logs.atuta_technical_logger("update_user_holiday_status_failed", exc_info=e)
            return {"status": "error", "message": "update_failed"}


    @classmethod
    def update_user_leave_status(cls, user_id, is_on_leave=None):
        """
        Update a user's is_on_leave status if a valid boolean value is provided.
        Logs both incoming data and updated status.
        """
        try:
            # Log incoming data
            Logs.atuta_logger(f"Received leave status update for user {user_id}: is_on_leave={is_on_leave}")

            user = CustomUser.objects.get(user_id=user_id)

            if is_on_leave is None:
                Logs.atuta_logger(f"No leave status provided for user {user_id}")
                return {"status": "info", "message": "no_status_provided"}

            # Ensure boolean type
            if isinstance(is_on_leave, str):
                is_on_leave_lower = is_on_leave.lower()
                if is_on_leave_lower in ("true", "1", "yes"):
                    is_on_leave = True
                elif is_on_leave_lower in ("false", "0", "no"):
                    is_on_leave = False
                else:
                    Logs.atuta_logger(f"Invalid is_on_leave value received for user {user_id}: {is_on_leave}")
                    return {"status": "error", "message": "invalid_status_value"}

            elif not isinstance(is_on_leave, bool):
                Logs.atuta_logger(f"Invalid is_on_leave type for user {user_id}: {type(is_on_leave)}")
                return {"status": "error", "message": "invalid_status_type"}

            user.is_on_leave = is_on_leave
            user.save()

            Logs.atuta_logger(f"Successfully updated leave status for user {user_id} to {is_on_leave}")
            return {"status": "success", "message": "leave_status_updated"}

        except ObjectDoesNotExist:
            Logs.atuta_logger(f"User {user_id} not found for leave status update")
            return {"status": "error", "message": "user_not_found"}
        except Exception as e:
            Logs.atuta_technical_logger("update_user_leave_status_failed", exc_info=e)
            return {"status": "error", "message": "update_failed"}

    @classmethod
    def update_user_fields(cls, user_id, nssf=None, sha=None, hourly_rate=None):
        """
        Update a user's NSSF, SHA, and hourly_rate fields only if valid values are provided.
        Converts inputs to appropriate types before saving.
        Logs both incoming data and updated fields.
        """
        try:
            # Log all incoming data from frontend
            Logs.atuta_logger(f"Received update request for user {user_id}: nssf={nssf}, sha={sha}, hourly_rate={hourly_rate}")

            user = CustomUser.objects.get(user_id=user_id)
            updated_fields = []

            # Only update if values are provided and valid
            if nssf not in (None, ""):
                user.nssf_number = str(nssf)
                updated_fields.append("nssf_number")

            if sha not in (None, ""):
                user.shif_sha_number = str(sha)
                updated_fields.append("shif_sha_number")

            if hourly_rate not in (None, ""):
                try:
                    user.hourly_rate = Decimal(hourly_rate)
                    updated_fields.append("hourly_rate")
                except (InvalidOperation, ValueError):
                    Logs.atuta_logger(f"Invalid hourly_rate received for user {user_id}: {hourly_rate}")
                    return {"status": "error", "message": "invalid_hourly_rate"}

            if updated_fields:
                user.save()
                Logs.atuta_logger(f"Successfully updated user {user_id} fields: {', '.join(updated_fields)}")
                return {"status": "success", "message": "user_updated"}
            else:
                Logs.atuta_logger(f"No fields to update for user {user_id}")
                return {"status": "info", "message": "no_fields_to_update"}

        except ObjectDoesNotExist:
            Logs.atuta_logger(f"User {user_id} not found for update")
            return {"status": "error", "message": "user_not_found"}
        except Exception as e:
            Logs.atuta_technical_logger("update_user_fields_failed", exc_info=e)
            return {"status": "error", "message": "update_failed"}


    @classmethod
    def get_user_details(cls, user_id):
        """
        Get complete user data using user_id.
        Returns user dict or error if not found.
        """
        try:
            user = CustomUser.objects.get(user_id=user_id)

            # List of fields to include
            FIELDS_TO_INCLUDE = [
                "first_name", "last_name", "email", "account", "user_role",
                "phone_number", "id_number", "nssf_number", "shif_sha_number",
                "hourly_rate", "hourly_rate_currency", "status",
                "is_present_today", "is_on_leave"
            ]

            user_data = model_to_dict(user, fields=FIELDS_TO_INCLUDE)

            # Ensure primary key (UUID) is included
            user_data["user_id"] = str(user.user_id)

            # Handle photo field safely
            user_data["photo"] = user.photo.url if user.photo else None

            # Log the complete fetched data
            Logs.atuta_logger(f"Fetched details for user {user.email}: {user_data}")

            return {
                "status": "success",
                "data": user_data
            }

        except ObjectDoesNotExist:
            Logs.atuta_logger(f"User not found for ID {user_id}")
            return {
                "status": "error",
                "message": "user_not_found"
            }

        except Exception as e:
            Logs.atuta_technical_logger("get_user_details_failed", exc_info=e)
            return {
                "status": "error",
                "message": "failed_to_fetch_user"
            }



    @classmethod
    def get_non_admin_users(cls):
        """
        Return a list of all users whose role is NOT 'admin'.
        Handles missing photo field safely.
        Converts boolean fields is_on_leave and is_on_holiday to 'yes'/'no'.
        """
        FIELDS_TO_INCLUDE = [
            'first_name', 'last_name', 'email', 'account', 
            'user_role', 'phone_number', 'hourly_rate', 
            'hourly_rate_currency', 'photo', 'status'
        ]
        
        try:
            users = CustomUser.objects.exclude(user_role="admin")
            user_list = []

            for user in users:
                # Create the dictionary from non-PK fields
                user_dict = model_to_dict(user, fields=FIELDS_TO_INCLUDE)
                
                # Add primary key
                user_dict["user_id"] = str(user.user_id)
                
                # Handle photo safely
                user_dict["photo"] = user.photo.url if user.photo else None
                
                # Convert boolean fields to 'yes'/'no'
                user_dict["is_on_leave"] = "yes" if user.is_on_leave else "no"
                user_dict["is_on_holiday"] = "yes" if user.is_on_holiday else "no"
                
                user_list.append(user_dict)

            Logs.atuta_logger(f"Successfully fetched {len(user_list)} non-admin users")
            return {
                "status": "success",
                "data": user_list
            }
        except Exception as e:
            Logs.atuta_technical_logger("get_non_admin_users_failed", exc_info=e)
            return {
                "status": "error",
                "message": "failed_to_fetch_users"
            }


    @classmethod
    def add_user(
        cls,
        email: str,
        first_name: str,
        last_name: str,
        password: str,
        user_role: str = "subordinate",
        phone_number: str = None,
        id_number: str = None,
        nssf_number: str = None,
        shif_sha_number: str = None,
        **extra_fields
    ):
        """
        Creates a new CustomUser with auto-generated username and optional staff fields.
        """
        if not first_name or not last_name or not password:
            return {"status": "error", "message": "missing_required_fields"}

        # Generate username
        base_username = f"{first_name}{last_name}".replace(" ", "").lower()
        username = base_username

        # Ensure uniqueness
        counter = 1
        while CustomUser.objects.filter(username=username).exists():
            username = f"{base_username}{counter}"
            counter += 1

        try:
            user = CustomUser.objects.create_user(
                first_name=first_name,
                last_name=last_name,
                phone_number=phone_number,
                password=password,
                user_role=user_role,
                username=username,         # <── auto inserted here
                email=email,
                id_number=id_number,
                nssf_number=nssf_number,
                shif_sha_number=shif_sha_number,
                **extra_fields
            )

            return {
                "status": "success",
                "message": f"user_created_{user.user_id}",
                "user_id": user.user_id,
                "username": user.username     # Return for login usage
            }

        except IntegrityError as e:
            Logs.atuta_technical_logger(f"user_creation_failed_{email}", exc_info=e)
            return {"status": "error", "message": "email_or_phone_exists"}

        except Exception as e:
            Logs.atuta_technical_logger(f"user_creation_failed_{email}", exc_info=e)
            return {"status": "error", "message": "user_creation_failed"}



    @classmethod
    def change_password(cls, user: CustomUser, old_password: str, new_password: str):
        """
        Change the password for a user after validating the old password.
        """
        if not old_password or not new_password:
            return {
                "status": "error",
                "message": "both_old_and_new_password_required"
            }

        try:
            # Verify the old password first
            if not user.check_password(old_password):
                return {
                    "status": "error",
                    "message": "old_password_incorrect"
                }

            # Set and save the new password
            user.set_password(new_password)
            user.save()

            return {
                "status": "success",
                "message": "password_changed_successfully"
            }

        except Exception as e:
            Logs.atuta_technical_logger(f"password_change_failed_user_{user.user_id}", exc_info=e)
            return {
                "status": "error",
                "message": "password_change_failed"
            }


    @classmethod
    def top_up_subscription(cls, user: CustomUser, days: int):
        if not isinstance(days, int) or days <= 0:
            return {
                "status": "error",
                "message": "invalid_days_param"
            }

        try:
            if user.subscription_expires is None:
                user.subscription_expires = datetime.date.today() + datetime.timedelta(days=days)
            else:
                user.subscription_expires = user.subscription_expires + datetime.timedelta(days=days)

            user.save()

            return {
                "status": "success",
                "message": "subscription_extended"
            }

        except Exception as e:
            Logs.atuta_technical_logger(f"subscription_top_up_failed_user_{user.id}", exc_info=e)
            return {
                "status": "error",
                "message": "subscription_update_failed"
            }


    @classmethod
    def full_name(cls, user: CustomUser):
        first = user.first_name or ""
        last = user.last_name or ""
        name = f"{first} {last}".strip() or user.username

        return {
            "status": "success",
            "message": {
                "full_name": name
            }
        }


    @classmethod
    def has_permission(cls, user: CustomUser, perm: str):
        if not perm:
            return {
                "status": "error",
                "message": "invalid_permission_param"
            }

        try:
            allowed = user.has_perm(perm)
            return {
                "status": "success",
                "message": {
                    "allowed": allowed,
                    "permission": perm
                }
            }
        except Exception as e:
            Logs.atuta_technical_logger(f"permission_check_failed_user_{user.id}", exc_info=e)
            return {
                "status": "error",
                "message": "permission_check_failed"
            }


    @classmethod
    def has_module_permission(cls, user: CustomUser, module: str):
        if not module:
            return {
                "status": "error",
                "message": "invalid_module_param"
            }

        try:
            allowed = user.has_module_perms(module)
            return {
                "status": "success",
                "message": {
                    "allowed": allowed,
                    "module": module
                }
            }

        except Exception as e:
            Logs.erratuta_technical_loggeror(f"module_permission_check_failed_user_{user.id}", exc_info=e)
            return {
                "status": "error",
                "message": "module_permission_check_failed"
            }